use crate::hci::*;

/// HCI Control and Baseband commands ([Vol 4] Part E, Section 7.3).
impl<T: host::Transport> Host<T> {
    /// Configures which events can be generated by the controller.
    pub async fn set_event_mask(&self, enable: EventMask) -> Result<()> {
        let r = self.exec_params(Opcode::SetEventMask, |cmd| {
            cmd.u64(enable.0);
        });
        r.await?.into()
    }

    /// Resets the controller's link manager, baseband, and link layer.
    pub async fn reset(&self) -> Result<()> {
        self.exec(Opcode::Reset).await?.into()
    }

    /// Turns flow control on or off for data sent from the controller to the
    /// host.
    pub async fn set_controller_to_host_flow_control(&self, enable: bool) -> Result<()> {
        let r = self.exec_params(Opcode::SetControllerToHostFlowControl, |cmd| {
            cmd.u8(u8::from(enable));
        });
        r.await?.into()
    }

    /// Sets the maximum size of the data portion of ACL and SCO data packets
    /// sent from the controller to the host.
    pub async fn host_buffer_size(&self, bs: BufferSize) -> Result<()> {
        let r = self.exec_params(Opcode::HostBufferSize, |cmd| {
            cmd.u16(bs.acl_data_len);
            cmd.u8(0);
            cmd.u16(bs.acl_num_pkts);
            cmd.u16(0_u16);
        });
        r.await?.into()
    }

    /// Configures which events can be generated by the controller.
    pub async fn set_event_mask_page_2(&self, enable: EventMask2) -> Result<()> {
        let r = self.exec_params(Opcode::SetEventMaskPage2, |cmd| {
            cmd.u64(enable.0);
        });
        r.await?.into()
    }

    /// Sets the LE Supported (Host) Link Manager Protocol feature bit.
    pub async fn write_le_host_support(&self, enable: bool) -> Result<()> {
        let r = self.exec_params(Opcode::WriteLeHostSupport, |cmd| {
            cmd.bool(enable).u8(0);
        });
        r.await?.into()
    }
}

/// `HCI_Set_Event_Mask` command parameters.
#[derive(Clone, Copy, Debug)]
#[repr(transparent)]
pub struct EventMask(u64);

impl EventMask {
    /// Creates an event mask from an iterator of events to enable. Unsupported
    /// events are ignored.
    #[inline]
    #[must_use]
    pub fn enable(events: impl Iterator<Item = EventCode>) -> Self {
        Self(Self::page(1, events))
    }

    #[inline]
    fn page(page: u8, events: impl Iterator<Item = EventCode>) -> u64 {
        let mut mask = 0;
        for v in events {
            mask |= v.mask(page);
        }
        mask
    }
}

/// `HCI_Set_Event_Mask_Page_2` command parameters.
#[derive(Clone, Copy, Debug)]
#[repr(transparent)]
pub struct EventMask2(u64);

impl EventMask2 {
    /// Creates an event mask from an iterator of events to enable. Unsupported
    /// events are ignored.
    #[inline]
    #[must_use]
    pub fn enable(events: impl Iterator<Item = EventCode>) -> Self {
        Self(EventMask::page(2, events))
    }
}
