fn main() {
    println!("cargo:rerun-if-changed=build.rs");
    #[cfg(feature = "generate")]
    generate::main();
}

#[cfg(feature = "generate")]
mod generate {
    use std::io::{Read, Write};
    use std::path::{Component, Path};
    use std::process::{Command, Stdio};
    use std::{env, fs, io, thread};

    use zip::ZipArchive;

    pub(super) fn main() {
        let mut zip = fetch("https://bitbucket.org/bluetooth-SIG/public/get/main.zip");
        gen_company_ids(&mut zip);
    }

    fn gen_company_ids<R: Read + io::Seek>(zip: &mut ZipArchive<R>) {
        const OUT: &'static str = "src/company_ids.rs";
        println!("cargo:rerun-if-changed={OUT}");
        #[derive(serde::Deserialize)]
        struct CompanyId {
            value: u16,
            name: String,
        }
        let ids = {
            #[derive(serde::Deserialize)]
            struct File {
                company_identifiers: Vec<CompanyId>,
            }
            let mut f: File = read(zip, "company_identifiers/company_identifiers.yaml");
            f.company_identifiers.sort_unstable_by_key(|c| c.value);
            f.company_identifiers
        };

        let mut tab = String::with_capacity(2 * ids.iter().fold(0, |n, id| n + id.name.len()));
        let mut end = Vec::<u16>::with_capacity(ids.len());
        let mut off = 0;
        for (i, id) in ids.iter().enumerate() {
            assert_eq!(usize::from(id.value), i);
            tab.push_str("\\\n        ");
            tab.push_str(&id.name.escape_debug().to_string());
            off += id.name.len();
            end.push(u16::try_from(off).expect("u16 overflow"));
        }
        tab.push_str("\\\n    ");

        let (max, last) = ids.last().map(|id| (id.value, &id.name)).unwrap();
        let src = format!(
            r#"
            use super::CompanyId;

            impl CompanyId {{
                pub(super) const TAB: &'static str = "{tab}";
                pub(super) const END: [u16; {max} as usize + 1] = {end:?};
            }}

            #[cfg(test)]
            mod tests {{
                #[test]
                fn company_ids() {{
                    use super::CompanyId;
                    assert_eq!(CompanyId(0).name(), Some("Ericsson AB"));
                    assert_eq!(CompanyId(0x0600).name(), Some("iRobot Corporation"));
                    assert_eq!(CompanyId({max:#06X}).name(), Some("{last}"));
                    assert_eq!(CompanyId({max:#06X} + 1).name(), None);
                    assert_eq!(CompanyId(u16::MAX).name(), None);
                }}
            }}
            "#
        );
        write(OUT, src);
    }

    fn fetch(url: impl AsRef<str>) -> ZipArchive<io::Cursor<Vec<u8>>> {
        let rsp = (ureq::get(url.as_ref()).call()).expect("failed to download repo");
        assert_eq!(rsp.content_type(), "application/zip");
        let len = (rsp.header("content-length")).expect("missing content-length header");
        let mut buf = Vec::with_capacity(len.parse().expect("invalid content-length header"));
        (rsp.into_reader().take(8 * 1024 * 1024))
            .read_to_end(&mut buf)
            .expect("failed to download file");
        ZipArchive::new(io::Cursor::new(buf)).expect("invalid zip file")
    }

    fn read<R, T>(zip: &mut ZipArchive<R>, path: impl AsRef<str>) -> T
    where
        R: Read + io::Seek,
        T: serde::de::DeserializeOwned,
    {
        let first = Path::new(zip.file_names().next().expect("empty zip file"));
        let root = (first.components().find_map(|c| match c {
            Component::Normal(root) => Some(root.to_string_lossy().to_string()),
            _ => None,
        }))
        .expect("failed to determine zip root");
        let r = (zip.by_name(&(root + "/" + path.as_ref()))).expect("file not found");
        serde_yaml::from_reader(r).expect("failed to parse yaml file")
    }

    fn write(path: impl AsRef<Path>, code: impl ToString) {
        const HEADER: &'static str = "// Code generated by build.rs. DO NOT EDIT.\n\n";
        let code = code.to_string();
        let mut src = String::with_capacity(HEADER.len() + code.len());
        src.push_str(HEADER);
        src.push_str(&code);
        fs::write(path, rustfmt(src)).expect("failed to write file");
    }

    fn rustfmt(src: String) -> Vec<u8> {
        let mut rustfmt = if let Ok(rustfmt) = env::var("RUSTFMT") {
            Command::new(rustfmt)
        } else {
            Command::new("rustfmt")
        };
        let mut child = rustfmt
            .stdin(Stdio::piped())
            .stdout(Stdio::piped())
            .stderr(Stdio::inherit())
            .spawn()
            .expect("failed to spawn rustfmt");
        let mut stdin = child.stdin.take().unwrap();
        let handle = thread::spawn(move || stdin.write_all(src.as_bytes()));
        let out = child.wait_with_output().expect("failed to wait on rustfmt");
        (handle.join().expect("stdin thread panic")).expect("failed to write to rustfmt");
        assert!(out.status.success(), "rustfmt error");
        out.stdout
    }
}
